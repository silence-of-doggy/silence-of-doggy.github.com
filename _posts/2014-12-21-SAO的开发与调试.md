---
layout: post
title: "SAO的开发与调试"
description: ""
category: 
tags: [HEVC，调试]
---
{% include JB/setup %}

目前主要从事HEVC编码器的算法方面的相关工作，主要是在36核的Tilera平台上进行开发工作。现在看来，这个编码器的未来还是相当令人堪忧的，不仅速度不能达到实时（30fps），BD-PSNR性能也差HM lowdelay P配置下近2dB。当然该编码器的前景不行主要还是这个平台的运算能力不足造成的，这使得即使在当前复杂度极低的编码环境下，仍然不能达到实时。

说一下该编码器的现状吧。这个编码器由实验室在Tilera平台上开发的264编码器（似乎这个264编码器主要还是买过来的）更改过来的，经过某学姐的“力挽狂澜”的修改过后（主要更正了并行时出现红块的bug和梳理了层次和运动搜索的代码，加入了亚像素搜索），再加上另一位同学的SIMD优化和我前期的在算法层面上的一些优化才有了目前这个版本。这个版本对于帧间预测，CU划分只有两层64x64和16x16，PU只有SKIP和Inter 2Nx2N，整像素搜索产用了TzSearch，亚像素搜索最多只搜索6个点（且只利用了4阶插值，HM中采用的是8阶插值）。各个模式之间的比较准则只利用了预测像素和原始像素的SAD值，而不是采用HM中的RD Cost，这样可以避免多次进入RDO环路，减少编码器复杂度。仅仅采用了SAD的模式判决准则，使得各个模式之间不能准确的判决，尤其是层间的判决，所以这里仅仅采用了两层CU的配置，并且还是隔层的（因为经测试不隔层的性能更加差）。

在学姐接手的时候，编码器的状况更加大大不如现在。其中特别突出的就是性能非常差，当时和老师常常争论——编码器性能差的主要原因是因为当前编码器的复杂度太低，工具集不够，经过几次周会的争论也许可能再加上私底下的，突然提出用x265编码器经过修改代码之后仿真当前编码器的复杂度，然后看看目前的这个性能是否合理。不得不说，这个想法还是非常具有建设性的，防止了打嘴炮的进一步升级，也指明了进一步的方向。我们老师在国外做过多年的工程，经验丰富，计算机硬件方面很是了解，工程师特质很明显，用数据说话（就像show me the code一样）。最终经过验证，那个版本的性能是合理的（期间，作为被边缘化的我也被拉入了这个浩大的工程）。同时在和编码器相当复杂度的x265上，逐一加上各个模块，仿真各个模块对低复杂度编码器性能提升的有效性，经验证，亚像素搜索和SAO模块对低复杂度的编码器有较大的性能提升。

于是学姐便加入了亚像素搜索，进行亚像素插值时采用了4阶滤波器，然后学姐去找工作了。于是，人手不够，我就被光荣的拉上去填坑啦，真是好开心啊。经过进一步的SIMD优化和一些算法层面的简化，得到一个较为稳定的版本，编码速度可以达到24到25fps的样子（仅仅针对4K序列）,BD-PSNR比HM lowdelay P配置下低2dB。然后个人觉得，编码器就进入了一个瓶颈。我在这个版本上卡了好久，主要是不知道要做些什么，性能和速度到底要那个呢？老师也没有什么好的想法，每次找我谈话总是说些有的没的，我呢一般也是会很配合——左耳朵进右耳朵出。有一天，老师又找我谈话，估计也是觉得现在这样下去实在不是什么办法，于是对我提出要进一步提升性能的要求，于是我便脱口而出，那现在来看肯定要加入SAO啊，老师笑了一声——好，那你就把SAO模块加进去吧。T_T本来这是要留给一个在x265上优化SAO模块的学弟做的，由于他上研一一直有课，所以相关工作一直没有开始。

So，只能说，here we are！
## 开发
说实话，我对开发SAO模块还是有一点期待的。因为平时做算法相关的工作，不需要编写大量的代码，基本上只要有些想法，然后在编码器上进行仿真，最后再把自己的算法集成到编码器上看看效果如何——基本上不需要写什么代码，这是第一次需要在编码器内部写大量的代码。

一开始找了一篇SAO标准相关的代码熟悉了一下标准，发现整个SAO模块还是及其简单的。然后就是看x265的代码，熟悉本身编码器的相关数据接口。这些工作大概花了一周——因为没有什么压力，所以这些都是进行的很是缓慢，在实验室主要还是做一些自己想做的事情。然后花了大概三天时间编写了代码（大部分是移植的x265的），编译通过后，那么就开始调试了。

## 调试
因为实在Linux环境下开发的，调试时要用gdb，以前从没有用过，所以让同学写了几个简单常用的指令便开始调试（这也是二八原则啊，很少一部分指令就能解决大部分的工作，gdb调试时遇到的问题应该会有另一篇blog来记录）。
调试的时候主要遇到了一下三个问题，其中第二个问题花了我大量的时间，主要还是方法不得当，自己感觉到了问题在哪里不好好去定位，而是像无头苍蝇一样只是看一遍又一遍的代码，毫无用处。

### 1. 动态分配内存空间时遇到的问题
导致这个bug主要是对编码器本身的代码不熟，**加入相关代码时没有去仔细关注自己添加的代码中要用到的上下文的变量的状态**,下面是要动态分配的一段空间

`ss.SaoLcuParam_tile = (SaoLcuParam_t*)malloc(sizeof(SaoLcuParam_t)*ss.num_rows*ss.num_cols*3);`

忽略具体参数的意义，这里犯的一个错误是在我一开始添加这句代码的时候，ss.num\_rows还没有进行初始化，导致这时实际上分配的内存空间为0（num_rows为0），导致后面访问这块区域时越界，更改了其他数据结构的值，Segmentation Fault
### 2. 运算操作符优先级没有搞清楚遇到的问题
这个错误是因为一下这句代码（在SAO中有个BO模式，把0-255像素范围划分为32个带，下面的iClassIdx就是对应像素的带的索引）

`iClassIdx = 1 + dest_tmp[x] >> 3;`

在我的认知中，毫不犹豫的认为移位先操作，然后才是加法，但事实却恰恰相反。这个bug估计花了我两天的时间，虽然我很早就意识到可能是BO的索引出现的问题，而且已经验证过了（不得不说我的直觉还是相当准的）。但还是花了这么久时间主要还是采取的方法不对，当时一开始花了好久的时间看代码，但是这种代码因为是自己写的所以在认识中就认为是对的，靠看根本就检查不出来。后来是自己初始化了一个LCU的像素，所以人工确定其最优模式，经过代码跑了一遍之后，缩小了代码的范围，再用gdb一步步跟踪的时候才定位到这个地方。

**想出好的方法比一开始就毫无章法的做更加重要，而平时多想多看多训练就是积累这些好的想法，使得到这个方法花的时间大大缩短。**
### 3. 初始化一块内存区域时写错了大小
发现这个问题一是因为加上了SAO模块之后编码器性能居然没有提升，而是因为单核编码时每次编码的比特数居然不是一模一样的,我当时也是搞不清楚问题出在哪儿，与别人交流的时候有人说可能是因为某些变量没有初始化（敏锐！），方式觉得也是蛮有道理，于是便在gdb下打印某些变量的值，遂发现了这个bug。
要统计SAO各个模式（BO,EO\_0,EO\_1,EO\_2,EO\_3）的统计信息，自己定义了一个结构体SaoStatInfo_t，然后要对其进行初始化，问题出在初始化上

`SaoStatInfo_t SaoStat;`

`memset(&SaoStat, 0, sizeof(&SaoStat));`

这发生了什么，相当于只初始化了&SaoStat这个指针大小的区域，而不是整个SaoStat结构体，所以该结构体大部分区域出现随机值，造成编码比特数不同，正确的代码应该是

`memset(&SaoStat, 0, sizeof(SaoStat));`
出现这个bug的原因是因为当时编写代码时想都没想就复制了前面的&SaoStat，**为保持编写代码的正确率，最好不要复制上下文的代码。**

写这篇文章的主要目的就是要写调试这部分的内容，记录一下调试时候遇到的问题，自己编写代码时出现的问题。所以此后的内容就简写了，调试工作主要还有一些pad的复制操作，整个slice一行编完之后进行标志位的更新，这个在多核并行时决定了各个任务的依赖关系。

## 优化
最终发现SAO模块的复杂度居然占了整个编码器的近50%，所以展开一些优化工作，主要从几个方面入手

- SIMD方面的优化

- 老师一直认为可能是SAO需要进行大量的I/O带宽，造成CPU需要等待I/O，这要怎么做？prefetch？

- 实在没办法加入一些快速算法，以性能换速度


12/23/2014 9:16:00 PM 